[[plugins]]
repo = 'vim-denops/denops.vim'
lazy = 0
merged = 0

[[plugins]]
repo = 'rhysd/committia.vim'
on_ft = 'gitcommit'
hook_add = '''
augroup GitSpellCheck
    autocmd!
    autocmd FileType gitcommit setlocal spell
augroup END

let g:committia_hooks = {}
function! g:committia_hooks.edit_open(info)
    setlocal spell
    setlocal spelllang+=cjk

    imap <buffer><C-n> <Plug>(committia-scroll-diff-down-half)
    imap <buffer><C-p> <Plug>(committia-scroll-diff-up-half)
endfunction

let g:committia_open_only_vim_starting = 1
let g:committia_use_singlecolumn = 'fallback'
let g:committia_min_window_size = 160
let g:committia_status_window_opencmd = 'belowright split'
let g:committia_diff_window_opencmd = 'botright vsplit'
let g:committia_singlecolumn_diff_window_opencmd = 'belowright split'
'''
hook_source = '''
call committia#open('git')
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
if = 'has("nvim")'
on_event = 'BufRead'
hook_post_update = 'TSUpdate'
hook_source = '''
lua << EOF
require'nvim-treesitter.configs'.setup {
    ensure_installed = 'all',
    highlight = {
        disable = { "vim" },
        enable = true
    },
}
EOF
'''

[[plugins]]
repo = 'nvim-lua/plenary.nvim'
if = 'has("nvim")'

[[plugins]]
repo = 'kyazdani42/nvim-web-devicons'

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
if = 'has("nvim")'
depends = ['plenary.nvim', 'nvim-web-devicons']
on_map = { n = '<Cmd>Telescope' }
hook_add = '''
nmap ; <Nop>
nmap ;f     <Cmd>Telescope find_files<CR>
nmap ;q     <Cmd>Telescope live_grep<CR>
nmap ;b     <Cmd>Telescope buffers<CR>
nmap ;h     <Cmd>Telescope help_tags<CR>
nmap ;t     <Cmd>Telescope treesitter<CR>
nmap ;s     <Cmd>Telescope current_buffer_fuzzy_find<CR>
nmap ;n     <Cmd>Telescope resume<CR><Esc>
nmap ;gG    <Cmd>Telescope git_commits<CR>
nmap ;gg    <Cmd>Telescope git_bcommits<CR>
nmap ;gb    <Cmd>Telescope git_branches<CR>
nmap ;ga    <Cmd>Telescope git_status<CR>
'''

[[plugins]]
repo = 'itchyny/vim-cursorword'
on_event = 'FileType'
hook_add = '''
let g:cursorword = 1
let g:cursorword_highlight = 1
autocmd MyAutoCmd FileType toml let b:cursorword = 0
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_source = """
" { before, input, after }
" | is cursor position.
call lexima#add_rule({'char': '<Tab>', 'at': '\%#\s*)', 'leave': ')'})
call lexima#add_rule({'char': '<Tab>', 'at': '\%#\s*"', 'leave': '"'})
call lexima#add_rule({'char': '<Tab>', 'at': '\%#\s*''', 'leave': ''''})
call lexima#add_rule({'char': '<Tab>', 'at': '\%#\s*]', 'leave': ']'})
call lexima#add_rule({'char': '<Tab>', 'at': '\%#\s*}', 'leave': '}'})

call lexima#add_rule({'char': '<CR>', 'at': '\%#''''''', 'input': '<CR>', 'input_after': '<CR>', 'filetype': 'toml'})

" cs:
" { |, $, $"|" }
call lexima#add_rule({'char': '$', 'input': '$\"', 'input_after': '\"', 'filetype': ['cs','razor']})

" html:
" { |, <, <|> }
call lexima#add_rule({'char': '<', 'input': '<', 'input_after': '>', 'filetype': ['html', 'razor']})
" { <input type="text"/|>, <Tab>, <input type="text"/>| }
call lexima#add_rule({'char': '<Tab>', 'at': '\%#>', 'leave': '>', 'filetype': ['html','razor']})
" { <input type="text"|>, <Tab>, <input type="text">|</input> }
call lexima#add_rule({
    \ 'char': '<Tab>',
    \ 'at': '<\(\w\+\)\s[^>]\+[^\/]\%#>',
    \ 'leave': '>',
    \ 'input_after': '</\1>',
    \ 'with_submatch': 1,
    \ 'filetype': ['html','razor']})
" { <div|>, <Tab>, <div>|</div> }
call lexima#add_rule({
    \ 'char': '<Tab>',
    \ 'at': '<\(\w\+\)\%#>',
    \ 'leave': '>',
    \ 'input_after': '</\1>',
    \ 'with_submatch': 1,
    \ 'filetype': ['html', 'razor']})
" { <|>, <BS>, | }
call lexima#add_rule({'char': '<BS>', 'at': '<\%#>', 'input': '<BS>', 'delete': '>', 'filetype': ['html', 'razor']})
" { <input type|>, =, <input type="|"> }
call lexima#add_rule({'char': '=', 'at': '<[^>]\+\s\w\+\%#>', 'input': '=\"', 'input_after': '\"', 'filetype': ['html','razor']})
" { |</div>, <Tab>, </div>| }
call lexima#add_rule({
    \ 'char': '<Tab>',
    \ 'at': '\%#<\/\w\+>',
    \ 'leave': '>',
    \ 'filetype': ['html', 'razor']
    \ })
" {
"   <div>|</div>,
"   <CR>,
"   <div>
"     |
"   </div>
" }
call lexima#add_rule({
    \ 'char': '<CR>',
    \ 'at': '>\%#<',
    \ 'input': '<CR>',
    \ 'input_after': '<CR>',
    \ 'filetype': ['html', 'razor']})

" markdown itemization rules
call lexima#add_rule({'char': '<CR>', 'at': '^\s*- \S\+\%#$', 'input': '<CR>- ', 'filetype': 'markdown'})
call lexima#add_rule({'char': '<CR>', 'at': '^\s\+- \%#$', 'input': '<BS><BS><BS>- ', 'filetype': 'markdown'})
call lexima#add_rule({'char': '<CR>', 'at': '^- \%#$', 'input': '<BS><BS>', 'filetype': 'markdown'})
call lexima#add_rule({'char': '-', 'at': '- \%#$', 'input': '<BS><BS>  - ', 'filetype': 'markdown'})
"""

[[plugins]]
repo = 'hrsh7th/vim-searchx'
if = 'has("nvim-0.5")'
on_map = { n = '<Cmd>call searchx#start' }
hook_add = '''
nnoremap / <Cmd>call searchx#start({ 'dir': 1 })<CR>

nnoremap N <Cmd>call searchx#prev()<CR>
nnoremap n <Cmd>call searchx#next()<CR>
'''
hook_source = '''
let g:searchx = {}
" auto jump if the recent input matches to any marker.
let g:searchx.auto_accept = v:true
" The scrolloff value for moving to next/prev.
let g:searchx.scrolloff = &scrolloff
" To diable scrolling animation.
let g:searchx.scrolltime = 0
" To enable auto nohlsearch after cursor is moved
let g:searchx.nohlsearch = {}
let g:searchx.nohlsearch.jump = v:true
" Marker characters.
let g:searchx.markers = split('ABCDEFGHIJKLMNOPQRSTUVWXYZ', '.\zs')
" Convert searchx pattern.
function g:searchx.convert(input) abort
    if a:input !~# '\k'
        return '\V' .. a:input
    endif
    return a:input[0] .. substitute(a:input[1:], '\\\@<! ', '.\\{-}', 'g')
endfunction
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
depends = 'denops.vim'
on_cmd = 'FuzzyMotion'
hook_add = '''
nmap <CR> <Cmd>FuzzyMotion<CR>
'''

[[plugins]]
repo = 'twitvim/twitvim'
if = 'has("python3")'
on_cmd = ['FriendsTwitter', 'PosttoTwitter']

[[plugins]]
repo = 'lambdalisue/gina.vim'
on_cmd = 'Gina'
hook_add = '''
nmap <Leader>aa <Cmd>Gina status<CR>
nmap <Leader>aA <Cmd>Gina changes HEAD<CR>
nmap <Leader>ac <Cmd>Gina commit --verbose<CR>
nmap <Leader>aC <Cmd>Gina commit --amend --verbose<CR>
nmap <Leader>ab <Cmd>Gina branch -av<CR>
nmap <Leader>at <Cmd>Gina tag<CR>
nmap <Leader>ag <Cmd>Gina grep<CR>
nmap <Leader>aq <Cmd>Gina qrep<CR>
nmap <Leader>ad <Cmd>Gina changes origin/HEAD...<CR>
nmap <Leader>ah <Cmd>Gina log --graph<CR>
nmap <Leader>aH <Cmd>Gina log --graph --all<CR>
nmap <Leader>al <Cmd>Gina log<CR>
nmap <Leader>aL <Cmd>Gina log :%<CR>
nmap <Leader>af <Cmd>Gina ls<CR>

autocmd MyAutoCmd FileType gina-commit setlocal spell
'''

[[plugins]]
repo = 'lambdalisue/fern.vim'
on_cmd = 'Fern'
hook_add = '''
nmap ;e <Cmd>Fern . -reveal=%<CR>
'''

[[plugins]]
repo = 'lambdalisue/nerdfont.vim'

[[plugins]]
repo = 'lambdalisue/fern-renderer-nerdfont.vim'
depends = 'nerdfont.vim'
on_source = 'fern.vim'
hook_add = '''
let g:fern#renderer = 'nerdfont'
'''

[[plugins]]
repo = 'lambdalisue/fern-git-status.vim'
on_source = 'fern.vim'
hook_source = '''
call fern_git_status#init()
'''

[[plugins]]
repo = 'lambdalisue/fern-mapping-git.vim'
on_source = 'fern.vim'

#[[plugins]]
#repo = 'rmagatti/auto-session'
#if = 'has("nvim")'
#on_event = 'VimEnter'
#hook_source = '''
#lua << EOF
#require('auto-session').setup {
#    log_level = 'error',
#    auto_session_enable_last_session = false,
#    auto_session_enabled = true,
#    auto_save_enabled = true,
#    auto_restore_enabled = true,
#}
#EOF
#'''

[[plugins]]
repo = 'rhysd/git-messenger.vim'
on_cmd = 'GitMessenger'
on_map = { n = '<Plug>(git-messenger)' }
hook_add = '''
let g:git_messenger_no_default_mappings = v:true
nmap <Leader>mp <Plug>(git-messenger)
'''

[[plugins]]
repo = 'vim-jp/syntax-vim-ex'
#on_ft = ['vim','toml']
hook_source = '''
syntax on
'''

[[plugins]]
repo = 'jlcrochet/vim-razor'
on_ft = ['razor']
